
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SANCTUM INTERFACE v2.0</title>
    <style>
        :root { --neon-orange: #ff9e00; --neon-blue: #00f3ff; --bg-dark: #050505; }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: monospace; user-select: none; color: white; }
        
        /* Start Screen */
        #layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; }
        #layer h1 { font-family: monospace; color: var(--neon-blue); letter-spacing: 8px; margin-bottom: 30px; font-size: 2.5rem; text-shadow: 0 0 30px var(--neon-blue); }
        .btn { padding: 20px 50px; background: transparent; border: 2px solid var(--neon-blue); color: var(--neon-blue); cursor: pointer; font-family: monospace; font-size: 1.2rem; letter-spacing: 4px; box-shadow: 0 0 20px rgba(0, 243, 255, 0.2); transition: 0.3s; }
        .btn:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 50px var(--neon-blue); }
        #status { margin-top: 20px; color: var(--neon-orange); font-size: 12px; }
        
        /* Hidden Camera */
        #hidden-cam { position: absolute; opacity: 0; pointer-events: none; }
        #video { transform: scaleX(-1); }
        
        /* HUD Overlay */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; opacity: 0; transition: opacity 0.5s; }
        #hud.active { opacity: 1; }
        .hud-row { display: flex; justify-content: space-between; }
        .hud-box { border: 1px solid rgba(0, 243, 255, 0.3); padding: 15px; background: rgba(0, 10, 20, 0.7); max-width: 280px; }
        .hud-box.left { border-left: 4px solid var(--neon-blue); border-top-left-radius: 15px; }
        .hud-box.right { border-right: 4px solid var(--neon-orange); border-top-right-radius: 15px; text-align: right; }
        .hud-box.bottom { border-bottom: 4px solid var(--neon-orange); align-self: center; text-align: center; margin-bottom: 20px; }
        .hud-title { font-family: monospace; font-size: 1.1rem; color: var(--neon-blue); text-shadow: 0 0 10px var(--neon-blue); margin: 0 0 5px 0; }
        .hud-value { color: var(--neon-orange); font-size: 0.9rem; }
        .scan-line { display: none; }
    </style>
    <script src="three.min.js"></script>
    <script>if(!window.THREE) document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>');</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
    <div id="layer">
        <h1>SANCTUM_INTERFACE</h1>
        <button class="btn" onclick="startApp()">INITIALIZE SYSTEM</button>
        <div id="status">ACCESSING BIOMETRIC SENSORS...</div>
    </div>
    <div id="hidden-cam"><video id="video" playsinline autoplay muted></video></div>
    
    <!-- HUD Overlay - ÊöÇÊó∂Á¶ÅÁî® -->
    <!--
    <div id="hud">
        <div class="hud-row">
            <div class="hud-box left">
                <div class="hud-title">SYSTEM: ONLINE</div>
                <span class="hud-value">Hand Tracking: <span id="system-status">STANDBY</span></span>
                <div class="scan-line"></div>
            </div>
            <div class="hud-box right">
                <div class="hud-title">ENERGY: 100%</div>
                <span id="gesture-status" class="hud-value">NO SIGNAL</span>
            </div>
        </div>
        <div class="hud-box bottom">
            <span>RAISE HAND TO CAST SPELL</span>
            <div id="debug-info" style="margin-top:10px; color:#0f0; font-size:14px;"></div>
        </div>
    </div>
    -->
    
    <!-- Audio Tags Removed: Using Web Audio API Synthesizer -->

    <script>
        let scene, camera, renderer;
        let hands, cameraObj;
        let sparkTex, glowTex;
        let particles;
        let sparks; // Áã¨Á´ãÁÅ´ÊòüÁ≥ªÁªü 
        let smallCircles = [], megaCircle;        
        let mergeProgress = 0, ultimateTimer = 0;
        let fixedUltPos = new THREE.Vector3();
        let lastHandCenter = new THREE.Vector3();

        const CAMERA_Z = 12;
        
        // === SYNTHESIZER (No external files required) ===
        const synth = {
            ctx: null,
            loops: [null, null],
            chargeOsc: null,
            chargeGain: null,
            init: function() {
                if(this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                
                // Create Drones (Loop 1 & 2)
                this.loops = [this.createDrone(100), this.createDrone(150)];
                
                // Create Charge Synth
                this.chargeOsc = this.ctx.createOscillator();
                this.chargeGain = this.ctx.createGain();
                this.chargeOsc.connect(this.chargeGain);
                this.chargeGain.connect(this.ctx.destination);
                this.chargeOsc.start();
                this.chargeGain.gain.value = 0;
            },
            createDrone: function(freq) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.value = freq;
                osc.type = 'sawtooth';
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                gain.gain.value = 0;
                return { node: gain, filter: filter };
            },
            setLoopVol: function(idx, vol) {
                if(!this.ctx) return;
                this.loops[idx].node.gain.setTargetAtTime(vol * 0.1, this.ctx.currentTime, 0.1);
            },
            setCharge: function(vol, progress) {
                if(!this.ctx) return;
                this.chargeGain.gain.setTargetAtTime(vol * 0.3, this.ctx.currentTime, 0.1);
                // Pitch rising from 200Hz to 800Hz
                this.chargeOsc.frequency.setTargetAtTime(200 + progress * 600, this.ctx.currentTime, 0.1);
            },
            playBoom: function() {
                if(!this.ctx) return;
                // White noise burst
                const bufferSize = this.ctx.sampleRate * 1.5; // 1.5 sec
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.value = 1000;
                
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(1, this.ctx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.5);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start();
            }
        };

        async function startApp() {
            document.querySelector('.btn').style.display = 'none';
            document.getElementById('status').innerText = "Syncing...";
            try { 
                synth.init(); // Init Audio
            } catch(e) {}

            try {
                initWorld(); await initMediaPipe();
                document.getElementById('layer').style.opacity = 0;
                setTimeout(() => document.getElementById('layer').style.display = 'none', 800);
                // document.getElementById('hud').classList.add('active');
                // document.getElementById('system-status').innerText = 'ACTIVE';
                try { document.documentElement.requestFullscreen(); } catch(e){}
            } catch(e) { alert(e); location.reload(); }
        }

        async function initMediaPipe() {
            const videoElement = document.getElementById('video');
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);
            cameraObj = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480, facingMode: 'user' });
            await cameraObj.start();
        }

        function onHandsResults(results) {
            const handData = [];
            if (results.multiHandLandmarks) {
                // document.getElementById('gesture-status').innerText = results.multiHandLandmarks.length > 0 ? `DETECTED: ${results.multiHandLandmarks.length}` : 'NO SIGNAL';
                results.multiHandLandmarks.forEach((lm) => {
                    const vFOV = THREE.Math.degToRad(camera.fov);
                    const height = 2 * Math.tan(vFOV / 2) * CAMERA_Z;
                    const width = height * camera.aspect;
                    const wx = -(lm[9].x - 0.5) * width; 
                    const wy = -(lm[9].y - 0.5) * height;
                    
                    // ËΩªÊùæÊâãÂäø: dist 0.02 -> 0%, 0.10 -> 100%
                    const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    let energy = (dist - 0.02) / 0.08; 
                    energy = Math.max(0, Math.min(1, energy));

                    handData.push({ pos: new THREE.Vector3(wx, wy, 0), energy: energy });
                });
            } else {
                // document.getElementById('gesture-status').innerText = 'NO SIGNAL';
            }

            let dist = 999;
            let center = new THREE.Vector3();

            if (handData.length === 2) {
                dist = handData[0].pos.distanceTo(handData[1].pos);
                center.copy(handData[0].pos).add(handData[1].pos).multiplyScalar(0.5);
                lastHandCenter.copy(center);
            } else {
                center.copy(lastHandCenter);
            }

            const bothHandsCharged = (handData.length === 2) && (handData[0].energy > 0.8) && (handData[1].energy > 0.8);

            // updateVolume ÂáΩÊï∞Â∑≤ÁßªÈô§Ôºå‰ΩøÁî® synth Êõø‰ª£
            
            // --- Áä∂ÊÄÅÊú∫ ---

        // --- Áä∂ÊÄÅÊú∫ ---
            
            // A. Áä∂ÊÄÅÊú∫ÈÄªËæëÂçáÁ∫ßÔºöÂ¢ûÂä†ÁÅ´ÊòüÊ∫ÖÂ∞ÑÂíåÈü≥ÊïàËÅîÂä®
            
            // 1. Â§ßÊãõÈáäÊîæ‰∏≠
            if (ultimateTimer > 0) {
                ultimateTimer--;
                megaCircle.update(fixedUltPos, true);
                smallCircles[0].mesh.visible = false;
                smallCircles[1].mesh.visible = false;
                
                // Á≤íÂ≠êÁ≥ªÁªüÂçáÁ∫ß
                // A. Ê†∏ÂøÉÊÇ¨ÊµÆ
                particles.emitSuspended(fixedUltPos);
                // B. Ëû∫ÊóãÈ£éÊö¥
                particles.emitSpiral(fixedUltPos, 2.0); 
                // C. üî• ÊåÅÁª≠Ê∑∑Ê≤åÁàÜÁÇ∏
                if(Math.random() > 0.5) particles.emitChaotic(fixedUltPos, 1.0);

                mergeProgress = 0;
                synth.setCharge(0, 0);
                synth.setLoopVol(0, 0);
                synth.setLoopVol(1, 0);

            // 2. ËûçÂêàËìÑÂäõ
            } else if (bothHandsCharged && dist < 9.0) {
                mergeProgress = Math.min(1.0, mergeProgress + 0.02);
                smallCircles.forEach((circle, i) => {
                    const target = new THREE.Vector3().lerpVectors(handData[i].pos, center, mergeProgress);
                    
                    // ÊóãËΩ¨ÈÄüÂ∫¶Âä†Âø´
                    const rotSpeed = 0.8 + mergeProgress * 0.5;
                    circle.update(target, rotSpeed, false);
                    
                    // üî• ËìÑÂäõÊó∂ÁöÑÊãñÂ∞æÂ¢ûÂº∫
                    particles.emitTrail(target, 1.5 + mergeProgress); 
                    
                    // üî• ËìÑÂäõÊó∂ÁöÑÁÅ´ÊòüÊ∫ÖÂ∞Ñ - ÊöÇÊó∂Á¶ÅÁî®
                    // if (mergeProgress > 0.1) {
                    //     sparks.emit(target, mergeProgress, circle.mesh.rotation.z);
                    // }
                });
                
                // üî• ËìÑÂäõÈü≥Êïà
                synth.setCharge(Math.min(1, mergeProgress), mergeProgress);
                
                synth.setLoopVol(0, 0.2);
                synth.setLoopVol(1, 0.2);
                if (mergeProgress >= 1.0) triggerUltimate(center);

            // 3. ÊôÆÈÄöÂèåÊåÅ
            } else {
                mergeProgress = Math.max(0, mergeProgress - 0.05);
                megaCircle.mesh.visible = false;
                synth.setCharge(0, 0);

                if (handData[0]) {
                    smallCircles[0].update(handData[0].pos, handData[0].energy);
                    particles.emitTrail(handData[0].pos, 0.6 + handData[0].energy);
                    synth.setLoopVol(0, handData[0].energy); 
                } else {
                    smallCircles[0].update(smallCircles[0].mesh.position, 0);
                    synth.setLoopVol(0, 0);
                }
                // ÁÅ´ÊòüÂú® animate ‰∏≠ÂèëÂ∞Ñ

                if (handData[1]) {
                    smallCircles[1].update(handData[1].pos, handData[1].energy);
                    particles.emitTrail(handData[1].pos, 0.6 + handData[1].energy);
                    synth.setLoopVol(1, handData[1].energy);
                } else {
                    smallCircles[1].update(smallCircles[1].mesh.position, 0);
                    synth.setLoopVol(1, 0);
                }
                // ÁÅ´ÊòüÂú® animate ‰∏≠ÂèëÂ∞Ñ
            }
        }

        function triggerUltimate(pos) {
            ultimateTimer = 240; 
            fixedUltPos.copy(pos);
            megaCircle.mesh.position.copy(fixedUltPos);
            megaCircle.mesh.visible = true;
            megaCircle.mesh.rotation.z = Math.random() * Math.PI;
            createShockwave(fixedUltPos);
            
            // ÂàùÂßãÂ§ßÁàÜÁÇ∏ (Â¢ûÂº∫Áâà)
            for(let i=0; i<20; i++) particles.emitBurst(fixedUltPos, 5.0); 
            for(let i=0; i<30; i++) particles.emitChaotic(fixedUltPos, 8.0); // üî• Ê∑∑ÂêàÊ∑∑Ê≤åÁ≤íÂ≠ê
            
            synth.playBoom(); // Êí≠ÊîæÂêàÊàêÈü≥Êïà
        }

        // ---------------- ËßÜËßâÁªÑ‰ª∂ ----------------
        class MagicCircle {
            constructor(scene, mat, scale) {
                this.mesh = new THREE.Group();
                this.baseScale = scale;
                this.mesh.scale.set(scale, scale, scale);
                this.rings = []; this.energy = 0; this.scene = scene;
                scene.add(this.mesh);
            }
            createRing(r, count, type, mat, speed, delay, rot=0) {
                const pos=[], basePos=[];
                for(let i=0; i<count; i++) {
                    const t=i/count, a=t*Math.PI*2;
                    let x,y;
                    if(type==='circle') { x=Math.cos(a)*r; y=Math.sin(a)*r; }
                    else if(type==='square') {
                        if(t<0.25){x=r; y=r*(1-8*t);} else if(t<0.5){x=r*(1-8*(t-0.25)); y=-r;}
                        else if(t<0.75){x=-r; y=-r*(1-8*(t-0.5));} else{x=-r*(1-8*(t-0.75)); y=r;}
                    } else { const R=r, k=r*0.3, h=2.4; x=(R-k)*Math.cos(a)+h*Math.cos(((R-k)/k)*a); y=(R-k)*Math.sin(a)-h*Math.sin(((R-k)/k)*a); }
                    x+=(Math.random()-0.5)*0.1; y+=(Math.random()-0.5)*0.1;
                    pos.push(x,y,0); basePos.push(x,y,0);
                }
                const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const p = new THREE.Points(geo, mat.clone()); p.rotation.z=rot; p.userData={speed, delay, count, basePos};
                this.mesh.add(p); this.rings.push(p);
            }
            updateLogic(targetPos, targetEnergy, isUltimate) {
                this.mesh.position.lerp(targetPos, 0.25);
                this.energy += (targetEnergy - this.energy) * 0.15;
                if(this.energy < 0.03 && !isUltimate) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                const pulse = isUltimate ? (1 + Math.sin(Date.now()*0.008)*0.1) : 1;
                this.mesh.scale.setScalar(this.baseScale * pulse);
                this.rings.forEach(ring => {
                    const d = ring.userData;
                    const prog = Math.max(0, Math.min(1, (this.energy-d.delay)/(1-d.delay)));
                    ring.geometry.setDrawRange(0, Math.floor(d.count * (isUltimate ? 1 : prog)));
                    let spin = d.speed * (1 + this.energy * 5); if(isUltimate) spin *= 3.0; 
                    ring.rotation.z += spin;
                    ring.material.opacity = isUltimate ? 1.0 : prog;
                    if(this.energy > 0.05 || isUltimate) {
                        const jitter = isUltimate ? 0.1 : 0.03 * this.energy;
                        const pos = ring.geometry.attributes.position.array; const base = d.basePos;
                        for(let i=0; i<d.count; i+=3) {
                             const idx = i*3; if(Math.random()>0.7) continue;
                             pos[idx] = base[idx] + (Math.random()-0.5)*jitter;
                             pos[idx+1] = base[idx+1] + (Math.random()-0.5)*jitter;
                        }
                        ring.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
        }
        class SmallCircle extends MagicCircle {
            constructor(scene, mat) {
                super(scene, mat, 0.75);
                this.createRing(5.5, 800, 'circle', mat, 0.005, 0.0);
                this.createRing(4.5, 1200, 'spiro', mat, -0.01, 0.1); 
                this.createRing(3.8, 600, 'square', mat, 0.02, 0.2);  
                this.createRing(2.0, 300, 'circle', mat, 0.05, 0.3);  
            }
            update(pos, energy) { super.updateLogic(pos, energy, false); }
        }
        class MegaCircle extends MagicCircle {
            constructor(scene, mat) {
                super(scene, mat, 1.5);
                // Á©∫Ê†∏ÂøÉ
                this.createRing(7.5, 2000, 'circle', mat, 0.002, 0); 
                this.createRing(6.0, 1500, 'square', mat, 0.005, 0); 
                this.createRing(6.0, 1500, 'square', mat, -0.005, 0, Math.PI/4);
                this.createRing(3.0, 800, 'circle', mat, -0.01, 0); 
            }
            update(pos, isActive) { 
                super.updateLogic(pos, 1.0, isActive);
            }
        }

        class ParticleSystem {
            constructor(scene, tex) {
                this.maxCount = 20000; this.idx = 0; // Â¢ûÂä†Á≤íÂ≠ê‰∏äÈôê
                const pos = new Float32Array(this.maxCount*3), vels = new Float32Array(this.maxCount*3), lifes = new Float32Array(this.maxCount);
                const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ size: 0.35, map: tex, color: 0xffdd88, blending: THREE.AdditiveBlending, transparent: true, opacity: 0, depthWrite:false });
                this.mesh = new THREE.Points(geo, mat); this.data = { vels, lifes };
                for(let i=0; i<this.maxCount*3; i++) pos[i] = 99999; scene.add(this.mesh);
            }
            emitTrail(center, intensity) {
                const count = Math.floor(2 + intensity * 5); 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const r = 1.0 + Math.random() * 2.0;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*0.5;
                    this.data.vels[i3] = (Math.random()-0.5)*0.02; this.data.vels[i3+1] = -0.03 - Math.random()*0.03; this.data.vels[i3+2] = (Math.random()-0.5)*0.02;
                    this.data.lifes[i] = 1.0; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitBurst(center, intensity) {
                const count = 100; 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const speed = 0.1 + Math.random() * 0.5;
                    this.mesh.geometry.attributes.position.array[i3] = center.x;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z;
                    this.data.vels[i3] = Math.cos(angle) * speed; this.data.vels[i3+1] = Math.sin(angle) * speed; this.data.vels[i3+2] = (Math.random()-0.5) * speed;
                    this.data.lifes[i] = 2.0; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitSpiral(center, intensity) {
                const count = 50;
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const r = 4.0 + Math.random() * 3.0;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*2.0;
                    const speed = 0.1;
                    this.data.vels[i3] = -Math.sin(angle) * speed;
                    this.data.vels[i3+1] = Math.cos(angle) * speed;
                    this.data.vels[i3+2] = 0;
                    this.data.lifes[i] = 1.5; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitSuspended(center) {
                const count = 30; 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const r = Math.random() * 2.5; const angle = Math.random() * 6.28;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*1.0;
                    this.data.vels[i3] = (Math.random()-0.5) * 0.05; this.data.vels[i3+1] = (Math.random()-0.5) * 0.05; this.data.vels[i3+2] = (Math.random()-0.5) * 0.05;
                    this.data.lifes[i] = 0.8 + Math.random(); this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            // üî• Êñ∞Â¢ûÔºöÊ∑∑Ê≤åÁàÜÁÇ∏Á≤íÂ≠ê (Chaotic)
            emitChaotic(center, intensity) {
                const count = Math.floor(10 * intensity);
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3;
                    // ‰ªé‰∏≠ÂøÉÁÇπÈöèÊú∫ÂèëÂ∞Ñ
                    this.mesh.geometry.attributes.position.array[i3] = center.x;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z;
                    
                    // 3D ÈöèÊú∫ÁêÉÂΩ¢ÊñπÂêë
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const speed = 0.3 + Math.random() * 0.5; // È´òÈÄü
                    
                    this.data.vels[i3] = speed * Math.sin(phi) * Math.cos(theta);
                    this.data.vels[i3+1] = speed * Math.sin(phi) * Math.sin(theta);
                    this.data.vels[i3+2] = speed * Math.cos(phi);
                    
                    this.data.lifes[i] = 0.5 + Math.random() * 0.5; // Áü≠ÂØøÂëΩÔºåÈó™ÁÉÅÊÑü
                    this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            update() {
                const pos = this.mesh.geometry.attributes.position.array; const vels = this.data.vels; const lifes = this.data.lifes; let active = false;
                for(let i=0; i<this.maxCount; i++) {
                    if (lifes[i] > 0) {
                        const i3 = i*3; pos[i3] += vels[i3]; pos[i3+1] += vels[i3+1]; pos[i3+2] += vels[i3+2];
                        vels[i3] *= 0.98; vels[i3+1] *= 0.98; vels[i3+2] *= 0.98; lifes[i] -= 0.015; 
                        if(lifes[i] <= 0) pos[i3] = 99999; else active = true;
                    }
                }
                if (active) this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createTextures() {
            // 1. È≠îÊ≥ïÈòµÁ≤íÂ≠êÁ∫πÁêÜ (ÊÅ¢Â§çÂéüÊù•ÁöÑÊ©ôËâ≤È£éÊ†º)
            const c=document.createElement('canvas'); c.width=32; c.height=32; const x=c.getContext('2d');
            x.fillStyle='#ffaa33'; x.beginPath(); x.arc(16,16,2,0,6.28); x.fill();
            const g=x.createRadialGradient(16,16,0,16,16,16); 
            g.addColorStop(0,'rgba(255,200,50,1)'); 
            g.addColorStop(0.5,'rgba(255,100,0,0.2)'); 
            g.addColorStop(1,'rgba(0,0,0,0)');
            x.fillStyle=g; x.fillRect(0,0,32,32); sparkTex = new THREE.CanvasTexture(c);

            // 2. Glow Texture
            const c2=document.createElement('canvas'); c2.width=64; c2.height=64; const x2=c2.getContext('2d');
            const g2=x2.createRadialGradient(32,32,0,32,32,32); g2.addColorStop(0,'rgba(255,255,200,1)'); g2.addColorStop(0.4,'rgba(255,150,0,0.5)'); g2.addColorStop(1,'rgba(0,0,0,0)');
            x2.fillStyle=g2; x2.fillRect(0,0,64,64); glowTex = new THREE.CanvasTexture(c2);
        }
        
        // üî• Áã¨Á´ãÁÅ´ÊòüÁ≥ªÁªü - ‰ªéÈ≠îÊ≥ïÈòµËæπÁºòÂêëÂõõÂë®ÊóãËΩ¨È£ûÊ∫Ö
        class SparkSystem {
            constructor(scene) {
                this.maxCount = 3000;
                this.idx = 0;
                
                // ÂàõÂª∫ÁÅ´Êòü‰∏ìÁî®Á∫πÁêÜ (Êòé‰∫ÆÁöÑÁôΩÈªÑËâ≤)
                const c = document.createElement('canvas'); c.width = 16; c.height = 16;
                const ctx = c.getContext('2d');
                const g = ctx.createRadialGradient(8,8,0,8,8,8);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(0.3, 'rgba(255,220,100,1)');
                g.addColorStop(0.6, 'rgba(255,100,0,0.5)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,16,16);
                this.tex = new THREE.CanvasTexture(c);
                
                // Âá†‰Ωï‰ΩìÂíåÊùêË¥®
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.maxCount * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                
                const mat = new THREE.PointsMaterial({
                    size: 0.3,
                    map: this.tex,
                    color: 0xffddaa,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(geo, mat);
                scene.add(this.mesh);
                
                // Á≤íÂ≠êÊï∞ÊçÆ
                this.vels = new Float32Array(this.maxCount * 3);
                this.lifes = new Float32Array(this.maxCount);
                
                // ÂàùÂßãÂåñ‰ΩçÁΩÆÂà∞Â±èÂπïÂ§ñ
                for(let i=0; i<this.maxCount*3; i++) pos[i] = 9999;
            }
            
            // ÂèëÂ∞ÑÁÅ´ÊòüÔºö‰ªéÈ≠îÊ≥ïÈòµËæπÁºòÔºåÊ≤øÂàáÁ∫ø+ÂæÑÂêëÈ£ûÂá∫
            emit(center, intensity, rotation) {
                const count = Math.floor(10 + intensity * 20); // Êõ¥ÂØÜÈõÜ
                const radius = 4.2; // È≠îÊ≥ïÈòµÂ§ñÂúàÂçäÂæÑ
                
                for(let k=0; k<count; k++) {
                    const i = this.idx;
                    const i3 = i * 3;
                    const pos = this.mesh.geometry.attributes.position.array;
                    
                    // ÂèëÂ∞ÑËßíÂ∫¶ = È≠îÊ≥ïÈòµÊóãËΩ¨Ëßí + ÈöèÊú∫ÂÅèÁßª
                    const angle = rotation + Math.random() * Math.PI * 2;
                    
                    // Ëµ∑Âßã‰ΩçÁΩÆÔºöÈ≠îÊ≥ïÈòµËæπÁºò
                    pos[i3] = center.x + Math.cos(angle) * radius;
                    pos[i3+1] = center.y + Math.sin(angle) * radius;
                    pos[i3+2] = center.z + (Math.random() - 0.5) * 0.5;
                    
                    // ÈÄüÂ∫¶Ôºö‰∏ªË¶ÅÊ≤øÂàáÁ∫øÊñπÂêëÈ£ûÂá∫ÔºàÊñúÂêëÊ∫ÖÂ∞ÑÔºâ
                    const speed = 0.2 + Math.random() * 0.3;
                    
                    // ÂàáÁ∫ø‰∏∫‰∏ªÔºåÂæÑÂêë‰∏∫ËæÖ
                    const radialRatio = 0.2;  // ÂæÑÂêëÂàÜÈáèÔºàÂêëÂ§ñÔºâ
                    const tangentRatio = 1.0; // ÂàáÁ∫øÂàÜÈáèÔºàÊóãËΩ¨ÊñπÂêëÔºâ
                    
                    // ÂàáÁ∫øÊñπÂêë (ÂûÇÁõ¥‰∫éÂæÑÂêëÔºåÈ°∫Êó∂Èíà)
                    const tangentX = -Math.sin(angle) * speed * tangentRatio;
                    const tangentY = Math.cos(angle) * speed * tangentRatio;
                    
                    // ÂæÑÂêëÊñπÂêë (ÂêëÂ§ñ)
                    const radialX = Math.cos(angle) * speed * radialRatio;
                    const radialY = Math.sin(angle) * speed * radialRatio;
                    
                    this.vels[i3] = tangentX + radialX + (Math.random()-0.5)*0.05;
                    this.vels[i3+1] = tangentY + radialY + (Math.random()-0.5)*0.05;
                    this.vels[i3+2] = (Math.random()-0.5) * 0.15;
                    
                    this.lifes[i] = 0.8 + Math.random() * 0.5;
                    this.idx = (this.idx + 1) % this.maxCount;
                }
                
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
            
            update() {
                const pos = this.mesh.geometry.attributes.position.array;
                let active = false;
                
                for(let i=0; i<this.maxCount; i++) {
                    if(this.lifes[i] > 0) {
                        const i3 = i * 3;
                        
                        // ÁßªÂä®
                        pos[i3] += this.vels[i3];
                        pos[i3+1] += this.vels[i3+1];
                        pos[i3+2] += this.vels[i3+2];
                        
                        // ÈáçÂäõ‰∏ãÂù†
                        this.vels[i3+1] -= 0.005;
                        
                        // ÈòªÂäõ
                        this.vels[i3] *= 0.98;
                        this.vels[i3+1] *= 0.98;
                        this.vels[i3+2] *= 0.98;
                        
                        // ÁîüÂëΩË°∞Âáè
                        this.lifes[i] -= 0.02;
                        
                        if(this.lifes[i] <= 0) {
                            pos[i3] = 9999; // ÈöêËóè
                        }
                        
                        active = true;
                    }
                }
                
                if(active) this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createShockwave(pos) {
            const geo = new THREE.RingGeometry(0.5, 1.5, 64);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffdd88, side: THREE.DoubleSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(pos); scene.add(mesh);
            let s = 1.0;
            const anim = () => { s += 1.5; mesh.scale.setScalar(s); mesh.material.opacity -= 0.02; if(mesh.material.opacity > 0) requestAnimationFrame(anim); else scene.remove(mesh); };
            anim();
        }

        function initWorld() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0, 0, CAMERA_Z);
            renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            createTextures();
            
            // È≠îÊ≥ïÈòµÊùêË¥® - ÊÅ¢Â§çÂéüÊù•ÁöÑÊ©ôËâ≤
            const mat = new THREE.PointsMaterial({ size: 0.25, map: sparkTex, color: 0xffaa33, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0 });
            
            smallCircles.push(new SmallCircle(scene, mat)); smallCircles.push(new SmallCircle(scene, mat));
            const megaMat = mat.clone(); megaMat.color.setHex(0xffffee); megaCircle = new MegaCircle(scene, megaMat);
            
            // Á≤íÂ≠êÁ≥ªÁªüÔºàÊãñÂ∞æÔºâ
            particles = new ParticleSystem(scene, sparkTex);
            
            // üî• Áã¨Á´ãÁöÑÁÅ´ÊòüÁ≥ªÁªü - ÊöÇÊó∂Á¶ÅÁî®ÊèêÂçáÊÄßËÉΩ
            // sparks = new SparkSystem(scene);
            
            animate();
        }
        function animate() { 
            requestAnimationFrame(animate); 
            particles.update();
            // sparks.update();  // ÊöÇÊó∂Á¶ÅÁî®
            
            // üî• ÁÅ´ÊòüË∑üÈ≠îÊ≥ïÈòµÂêåÊ≠•ÂèëÂ∞Ñ - ÊöÇÊó∂Á¶ÅÁî®
            // smallCircles.forEach(circle => {
            //     if (circle.mesh.visible) {
            //         sparks.emit(circle.mesh.position, circle.energy, Date.now() * 0.002);
            //     }
            // });
            
            renderer.render(scene, camera); 
        }
        window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
