<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dr. Strange AR Interface</title>
    
    <!-- Three.js r128 (same as desktop version) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Hands (All from CDN to ensure version consistency) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        :root {
            --neon-orange: #ff9e00;
            --neon-blue: #00f3ff;
            --bg-dark: #050505;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Share Tech Mono', monospace;
            color: white;
        }

        /* Debug Console */
        #debug-console {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 300px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.8);
            border: 1px solid red;
            color: #ff5555;
            font-size: 12px;
            padding: 10px;
            z-index: 100;
            display: none; /* Hidden by default, shown on error */
            pointer-events: none;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD Elements */
        .hud-corner {
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 15px;
            background: rgba(0, 10, 20, 0.5);
            backdrop-filter: blur(5px);
            max-width: 300px;
        }

        .top-left { border-top-left-radius: 20px; border-right: 4px solid var(--neon-blue); }
        .top-right { text-align: right; border-top-right-radius: 20px; border-left: 4px solid var(--neon-orange); }
        .bottom-center { 
            align-self: center; 
            text-align: center; 
            border-bottom: 4px solid var(--neon-orange);
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            font-size: 1.5rem;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .status-text {
            color: var(--neon-orange);
            font-size: 0.9rem;
            margin-top: 5px;
            display: block;
        }

        .scan-line {
            width: 100%;
            height: 2px;
            background: var(--neon-blue);
            animation: scan 2s infinite linear;
            opacity: 0.5;
        }

        @keyframes scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #start-btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 20px 50px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
        }

        #start-btn:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 50px var(--neon-blue);
        }

        #loading {
            display: none;
            margin-top: 20px;
            color: var(--neon-orange);
            animation: blink 1s infinite;
        }

        @keyframes blink { 50% { opacity: 0.3; } }

        /* Video Input - Keep it in DOM but invisible */
        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px; 
            height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        #webgl-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Debug Console -->
    <div id="debug-console"></div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 style="font-size: 3rem; margin-bottom: 40px;">SANCTUM_INTERFACE_v2.0</h1>
        <button id="start-btn">INITIALIZE SYSTEM</button>
        <div id="loading">ACCESSING BIOMETRIC SENSORS...</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="hud-corner top-left">
            <h1>SYSTEM: ONLINE</h1>
            <span class="status-text">Hand Tracking: <span id="system-status">STANDBY</span></span>
            <div class="scan-line" style="margin-top:10px"></div>
        </div>
        <div class="hud-corner top-right">
            <h1>ENERGY: 100%</h1>
            <span id="gesture-status" class="status-text">NO SIGNAL</span>
        </div>
        <div class="hud-corner bottom-center">
            <span>RAISE HAND TO CAST SPELL</span>
        </div>
    </div>

    <!-- Video Input -->
    <video class="input_video" playsinline></video>
    
    <!-- 3D Container -->
    <div id="webgl-container"></div>

    <script>
        // ============== DESKTOP VERSION RENDERING LOGIC ==============
        // Copied directly from desktop_version/index.html for identical performance
        
        let scene, camera, renderer;
        let hands, cameraObj;
        let sparkTex, glowTex;
        let particles; 
        let smallCircles = [], megaCircle;        
        let mergeProgress = 0, ultimateTimer = 0;
        let fixedUltPos = new THREE.Vector3();
        let lastHandCenter = new THREE.Vector3();

        const CAMERA_Z = 12;
        
        // UI Elements
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const loading = document.getElementById('loading');
        const systemStatus = document.getElementById('system-status');
        const gestureStatus = document.getElementById('gesture-status');
        const videoElement = document.querySelector('.input_video');

        async function startApp() {
            startBtn.style.display = 'none';
            loading.style.display = 'block';
            loading.innerText = "SYNCING...";

            try {
                initWorld(); 
                await initMediaPipe();
                startScreen.style.opacity = '0';
                setTimeout(() => startScreen.style.display = 'none', 800);
                systemStatus.innerText = "ACTIVE";
                try { document.documentElement.requestFullscreen(); } catch(e){}
            } catch(e) { 
                loading.innerText = "SYSTEM FAILURE: " + e.message;
                console.error(e);
            }
        }

        async function initMediaPipe() {
            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);
            cameraObj = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
            await cameraObj.start();
        }

        function onHandsResults(results) {
            const handData = [];
            if (results.multiHandLandmarks) {
                gestureStatus.innerText = `DETECTED: ${results.multiHandLandmarks.length}`;
                results.multiHandLandmarks.forEach((lm) => {
                    const vFOV = THREE.Math.degToRad(camera.fov);
                    const height = 2 * Math.tan(vFOV / 2) * CAMERA_Z;
                    const width = height * camera.aspect;
                    const wx = -(lm[9].x - 0.5) * width; 
                    const wy = -(lm[9].y - 0.5) * height;
                    
                    const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    let energy = (dist - 0.02) / 0.08; 
                    energy = Math.max(0, Math.min(1, energy));

                    handData.push({ pos: new THREE.Vector3(wx, wy, 0), energy: energy });
                });
            } else {
                gestureStatus.innerText = "NO SIGNAL";
            }

            let dist = 999;
            let center = new THREE.Vector3();

            if (handData.length === 2) {
                dist = handData[0].pos.distanceTo(handData[1].pos);
                center.copy(handData[0].pos).add(handData[1].pos).multiplyScalar(0.5);
                lastHandCenter.copy(center);
            } else {
                center.copy(lastHandCenter);
            }

            const bothHandsCharged = (handData.length === 2) && (handData[0].energy > 0.8) && (handData[1].energy > 0.8);

            // --- State Machine ---
            if (ultimateTimer > 0) {
                ultimateTimer--;
                megaCircle.update(fixedUltPos, true);
                smallCircles[0].mesh.visible = false;
                smallCircles[1].mesh.visible = false;
                particles.emitSuspended(fixedUltPos);
                particles.emitSpiral(fixedUltPos, 2.0); 
                if(Math.random() > 0.5) particles.emitChaotic(fixedUltPos, 1.0);
                mergeProgress = 0;

            } else if (bothHandsCharged && dist < 9.0) {
                mergeProgress = Math.min(1.0, mergeProgress + 0.02);
                smallCircles.forEach((circle, i) => {
                    const target = new THREE.Vector3().lerpVectors(handData[i].pos, center, mergeProgress);
                    circle.update(target, 0.8 + mergeProgress*0.2, false);
                    particles.emitTrail(target, 1.5); 
                });
                if (mergeProgress >= 1.0) triggerUltimate(center);

            } else {
                mergeProgress = Math.max(0, mergeProgress - 0.05);
                megaCircle.mesh.visible = false;

                if (handData[0]) {
                    smallCircles[0].update(handData[0].pos, handData[0].energy);
                    if(smallCircles[0].mesh.visible) particles.emitTrail(smallCircles[0].mesh.position, 0.6 + handData[0].energy);
                } else {
                    smallCircles[0].update(smallCircles[0].mesh.position, 0);
                }

                if (handData[1]) {
                    smallCircles[1].update(handData[1].pos, handData[1].energy);
                    if(smallCircles[1].mesh.visible) particles.emitTrail(smallCircles[1].mesh.position, 0.6 + handData[1].energy);
                } else {
                    smallCircles[1].update(smallCircles[1].mesh.position, 0);
                }
            }
        }

        function triggerUltimate(pos) {
            ultimateTimer = 240; 
            fixedUltPos.copy(pos);
            megaCircle.mesh.position.copy(fixedUltPos);
            megaCircle.mesh.visible = true;
            megaCircle.mesh.rotation.z = Math.random() * Math.PI;
            createShockwave(fixedUltPos);
            for(let i=0; i<20; i++) particles.emitBurst(fixedUltPos, 5.0); 
            for(let i=0; i<30; i++) particles.emitChaotic(fixedUltPos, 8.0);
        }

        // ---------------- Visual Components (IDENTICAL TO DESKTOP) ----------------
        class MagicCircle {
            constructor(scene, mat, scale) {
                this.mesh = new THREE.Group();
                this.baseScale = scale;
                this.mesh.scale.set(scale, scale, scale);
                this.rings = []; this.energy = 0; this.scene = scene;
                scene.add(this.mesh);
            }
            createRing(r, count, type, mat, speed, delay, rot=0) {
                const pos=[], basePos=[];
                for(let i=0; i<count; i++) {
                    const t=i/count, a=t*Math.PI*2;
                    let x,y;
                    if(type==='circle') { x=Math.cos(a)*r; y=Math.sin(a)*r; }
                    else if(type==='square') {
                        if(t<0.25){x=r; y=r*(1-8*t);} else if(t<0.5){x=r*(1-8*(t-0.25)); y=-r;}
                        else if(t<0.75){x=-r; y=-r*(1-8*(t-0.5));} else{x=-r*(1-8*(t-0.75)); y=r;}
                    } else { const R=r, k=r*0.3, h=2.4; x=(R-k)*Math.cos(a)+h*Math.cos(((R-k)/k)*a); y=(R-k)*Math.sin(a)-h*Math.sin(((R-k)/k)*a); }
                    x+=(Math.random()-0.5)*0.1; y+=(Math.random()-0.5)*0.1;
                    pos.push(x,y,0); basePos.push(x,y,0);
                }
                const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const p = new THREE.Points(geo, mat.clone()); p.rotation.z=rot; p.userData={speed, delay, count, basePos};
                this.mesh.add(p); this.rings.push(p);
            }
            updateLogic(targetPos, targetEnergy, isUltimate) {
                this.mesh.position.lerp(targetPos, 0.25);
                this.energy += (targetEnergy - this.energy) * 0.15;
                if(this.energy < 0.01 && !isUltimate) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                const pulse = isUltimate ? (1 + Math.sin(Date.now()*0.008)*0.1) : 1;
                this.mesh.scale.setScalar(this.baseScale * pulse);
                this.rings.forEach(ring => {
                    const d = ring.userData;
                    const prog = Math.max(0, Math.min(1, (this.energy-d.delay)/(1-d.delay)));
                    ring.geometry.setDrawRange(0, Math.floor(d.count * (isUltimate ? 1 : prog)));
                    let spin = d.speed * (1 + this.energy * 5); if(isUltimate) spin *= 3.0; 
                    ring.rotation.z += spin;
                    ring.material.opacity = isUltimate ? 1.0 : prog;
                    if(this.energy > 0.05 || isUltimate) {
                        const jitter = isUltimate ? 0.1 : 0.03 * this.energy;
                        const pos = ring.geometry.attributes.position.array; const base = d.basePos;
                        for(let i=0; i<d.count; i+=3) {
                             const idx = i*3; if(Math.random()>0.7) continue;
                             pos[idx] = base[idx] + (Math.random()-0.5)*jitter;
                             pos[idx+1] = base[idx+1] + (Math.random()-0.5)*jitter;
                        }
                        ring.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
        }
        class SmallCircle extends MagicCircle {
            constructor(scene, mat) {
                super(scene, mat, 0.75);
                this.createRing(5.5, 800, 'circle', mat, 0.005, 0.0);
                this.createRing(4.5, 1200, 'spiro', mat, -0.01, 0.1); 
                this.createRing(3.8, 600, 'square', mat, 0.02, 0.2);  
                this.createRing(2.0, 300, 'circle', mat, 0.05, 0.3);  
            }
            update(pos, energy) { super.updateLogic(pos, energy, false); }
        }
        class MegaCircle extends MagicCircle {
            constructor(scene, mat) {
                super(scene, mat, 1.5);
                this.createRing(7.5, 2000, 'circle', mat, 0.002, 0); 
                this.createRing(6.0, 1500, 'square', mat, 0.005, 0); 
                this.createRing(6.0, 1500, 'square', mat, -0.005, 0, Math.PI/4);
                this.createRing(3.0, 800, 'circle', mat, -0.01, 0); 
            }
            update(pos, isActive) { 
                super.updateLogic(pos, 1.0, isActive);
            }
        }

        class ParticleSystem {
            constructor(scene, tex) {
                this.maxCount = 20000; this.idx = 0;
                const pos = new Float32Array(this.maxCount*3), vels = new Float32Array(this.maxCount*3), lifes = new Float32Array(this.maxCount);
                const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ size: 0.35, map: tex, color: 0xffdd88, blending: THREE.AdditiveBlending, transparent: true, opacity: 0, depthWrite:false });
                this.mesh = new THREE.Points(geo, mat); this.data = { vels, lifes };
                for(let i=0; i<this.maxCount*3; i++) pos[i] = 99999; scene.add(this.mesh);
            }
            emitTrail(center, intensity) {
                const count = Math.floor(2 + intensity * 5); 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const r = 1.0 + Math.random() * 2.0;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*0.5;
                    this.data.vels[i3] = (Math.random()-0.5)*0.02; this.data.vels[i3+1] = -0.03 - Math.random()*0.03; this.data.vels[i3+2] = (Math.random()-0.5)*0.02;
                    this.data.lifes[i] = 1.0; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitBurst(center, intensity) {
                const count = 100; 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const speed = 0.1 + Math.random() * 0.5;
                    this.mesh.geometry.attributes.position.array[i3] = center.x;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z;
                    this.data.vels[i3] = Math.cos(angle) * speed; this.data.vels[i3+1] = Math.sin(angle) * speed; this.data.vels[i3+2] = (Math.random()-0.5) * speed;
                    this.data.lifes[i] = 2.0; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitSpiral(center, intensity) {
                const count = 50;
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const angle = Math.random() * 6.28; const r = 4.0 + Math.random() * 3.0;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*2.0;
                    const speed = 0.1;
                    this.data.vels[i3] = -Math.sin(angle) * speed;
                    this.data.vels[i3+1] = Math.cos(angle) * speed;
                    this.data.vels[i3+2] = 0;
                    this.data.lifes[i] = 1.5; this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitSuspended(center) {
                const count = 30; 
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3; const r = Math.random() * 2.5; const angle = Math.random() * 6.28;
                    this.mesh.geometry.attributes.position.array[i3] = center.x + Math.cos(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y + Math.sin(angle)*r;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z + (Math.random()-0.5)*1.0;
                    this.data.vels[i3] = (Math.random()-0.5) * 0.05; this.data.vels[i3+1] = (Math.random()-0.5) * 0.05; this.data.vels[i3+2] = (Math.random()-0.5) * 0.05;
                    this.data.lifes[i] = 0.8 + Math.random(); this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            emitChaotic(center, intensity) {
                const count = Math.floor(10 * intensity);
                for(let k=0; k<count; k++) {
                    const i = this.idx; const i3 = i*3;
                    this.mesh.geometry.attributes.position.array[i3] = center.x;
                    this.mesh.geometry.attributes.position.array[i3+1] = center.y;
                    this.mesh.geometry.attributes.position.array[i3+2] = center.z;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const speed = 0.3 + Math.random() * 0.5;
                    this.data.vels[i3] = speed * Math.sin(phi) * Math.cos(theta);
                    this.data.vels[i3+1] = speed * Math.sin(phi) * Math.sin(theta);
                    this.data.vels[i3+2] = speed * Math.cos(phi);
                    this.data.lifes[i] = 0.5 + Math.random() * 0.5;
                    this.idx = (this.idx + 1) % this.maxCount;
                }
            }
            update() {
                const pos = this.mesh.geometry.attributes.position.array; const vels = this.data.vels; const lifes = this.data.lifes; let active = false;
                for(let i=0; i<this.maxCount; i++) {
                    if (lifes[i] > 0) {
                        const i3 = i*3; pos[i3] += vels[i3]; pos[i3+1] += vels[i3+1]; pos[i3+2] += vels[i3+2];
                        vels[i3] *= 0.98; vels[i3+1] *= 0.98; vels[i3+2] *= 0.98; lifes[i] -= 0.015; 
                        if(lifes[i] <= 0) pos[i3] = 99999; else active = true;
                    }
                }
                if (active) this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createTextures() {
            const c=document.createElement('canvas'); c.width=32; c.height=32; const x=c.getContext('2d');
            x.fillStyle='#ffaa33'; x.beginPath(); x.arc(16,16,2,0,6.28); x.fill();
            const g=x.createRadialGradient(16,16,0,16,16,16); g.addColorStop(0,'rgba(255,200,50,1)'); g.addColorStop(0.5,'rgba(255,100,0,0.2)'); g.addColorStop(1,'rgba(0,0,0,0)');
            x.fillStyle=g; x.fillRect(0,0,32,32); sparkTex = new THREE.CanvasTexture(c);

            const c2=document.createElement('canvas'); c2.width=64; c2.height=64; const x2=c2.getContext('2d');
            const g2=x2.createRadialGradient(32,32,0,32,32,32); g2.addColorStop(0,'rgba(255,255,200,1)'); g2.addColorStop(0.4,'rgba(255,150,0,0.5)'); g2.addColorStop(1,'rgba(0,0,0,0)');
            x2.fillStyle=g2; x2.fillRect(0,0,64,64); glowTex = new THREE.CanvasTexture(c2);
        }

        function createShockwave(pos) {
            const geo = new THREE.RingGeometry(0.5, 1.5, 64);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffdd88, side: THREE.DoubleSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(pos); scene.add(mesh);
            let s = 1.0;
            const anim = () => { s += 1.5; mesh.scale.setScalar(s); mesh.material.opacity -= 0.02; if(mesh.material.opacity > 0) requestAnimationFrame(anim); else scene.remove(mesh); };
            anim();
        }

        function initWorld() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0, 0, CAMERA_Z);
            renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            createTextures();
            const mat = new THREE.PointsMaterial({ size: 0.25, map: sparkTex, color: 0xffaa33, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0 });
            smallCircles.push(new SmallCircle(scene, mat)); smallCircles.push(new SmallCircle(scene, mat));
            const megaMat = mat.clone(); megaMat.color.setHex(0xffffee); megaCircle = new MegaCircle(scene, megaMat);
            particles = new ParticleSystem(scene, sparkTex);
            animate();
        }
        
        function animate() { requestAnimationFrame(animate); particles.update(); renderer.render(scene, camera); }
        
        window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };

        // --- Start Button Event ---
        startBtn.addEventListener('click', startApp);
    </script>
</body>
</html>
